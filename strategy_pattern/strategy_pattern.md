# 手撸设计模式（一）：策略模式

## 模拟鸭子

假如让你设计一个模拟鸭子的游戏，鸭子的种类繁多，每种鸭子都会游泳和嘎嘎叫，你会如何设计？我想，大部分人和我一样，首先想到的是使用继承。

![1555421796700](C:\Users\ethan\Pictures\ProcessOn\strategy\模拟鸭子.png)

这确实是一个不错的设计，使用了标准的OO（面向对象）技术，设计了一个鸭子基类，并让各种鸭子继承它，每种鸭子都会quack和swim，并实现各自的display方法。但是，软件开发有一个不变的真理，就是**改变**。一款软件，无论一开始设计得多好，过一阵子后，都需要迭代和更新。驱动改变的因素有很多，比如功能优化、新功能添加、软件兼容等等。

让我们回到模拟鸭子的游戏，用户觉得不过瘾，还想让鸭子能飞。嘿，能飞还不简单，这样不就行了：

![1555422244371](C:\Users\ethan\Pictures\ProcessOn\strategy\模拟鸭子(1).png)

我们忽略了一件事，并非所有鸭子都会飞。假设现在添加一个子类叫RubberDuck(橡皮鸭)，也继承自Duck，就会出现不符合逻辑的情况（会飞的橡皮鸭）。如果在RubberDuck里覆盖掉fly()方法呢？像这样：

```python
class RubberDuck(Duck):
    def display():
        print('黄色的橡皮鸭，经常出没于各家各户的浴室中')
    
    def quack():
        print('吱吱吱') # 覆盖quack，因为橡皮鸭的叫声与正常鸭子的叫声有所不同
    
    def fly():
        pass # 覆盖fly，因为橡皮鸭不会飞，所以调用时啥也不干
```

这只能解决目前的问题，如果以后有个ModelDuck(模型鸭)，不会飞也不会叫；或者有个虽然会飞，但叫声跟橡皮鸭一样的类，又该怎么办？如果都用覆盖，代码就不能复用，以后维护起来就是恶梦。

## 解决方案

通过上面的例子，我们发现在基类中加上新的行为，会使得某些子类也具有这个不恰当的行为，如果在子类中覆盖该行为，又会导致代码重复且不能复用的情况。针对此情况，《Head First设计模式》给我们提供了解决方案：






